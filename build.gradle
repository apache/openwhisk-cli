/*
    Holding these lines for when gogradle 0.8.1 is released.
plugins {
    id 'com.github.blindpirate.gogradle' version '0.8.1'
}
*/

buildscript {
    repositories {
        mavenLocal()
        jcenter()
    }
    dependencies {
        classpath "org.antlr:antlr4:4.6"
        classpath group: 'com.google.inject', name: 'guice', version: '4.1.0'
        classpath group: 'org.apache.commons', name: 'commons-lang3', version: '3.5'
        classpath group: 'org.apache.commons', name: 'commons-collections4', version: '4.1'
        classpath group: 'commons-codec', name: 'commons-codec', version: '1.10'
        classpath group: 'commons-io', name: 'commons-io', version: '2.5'
        classpath 'com.google.guava:guava:20.0'
        classpath 'com.github.zafarkhaja:java-semver:0.9.0'
        classpath group: 'org.jsoup', name: 'jsoup', version: '1.7.2'
        classpath group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.8.5'
        classpath group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version: '2.8.5'
        classpath group: 'com.google.code.findbugs', name: 'annotations', version: '3.0.1'
        classpath group: 'com.fasterxml.jackson.dataformat', name: 'jackson-dataformat-yaml', version: '2.8.5'
        classpath group: 'net.lingala.zip4j', name: 'zip4j', version: '1.3.2'
        classpath group: 'org.apache.ant', name: 'ant', version: '1.10.0'
        classpath group: 'com.typesafe.sbt', name: 'sbt-interface', version: '0.13.13'
        classpath group: 'com.fasterxml.jackson.dataformat', name: 'jackson-dataformat-xml', version: '2.6.3'
        classpath group: 'org.codehaus.woodstox', name: 'woodstox-core-asl', version: '4.4.1'
        classpath group: 'org.jooq', name: 'joor', version: '0.9.6'
        classpath 'com.moandjiezana.toml:toml4j:0.7.2'
        classpath files('../gogradle/build/libs/gogradle-0.8.1.jar')
    }
}

apply plugin: 'com.github.blindpirate.gogradle'

golang {
    packagePath = 'github.com/apache/incubator-openwhisk-cli' as String
    buildTags = (rootProject.findProperty('goTags')?:'').split(',')
}

dependencies {
    golang {
        // TODO - validate where version should and should not be locked.
        // BEGIN - Imported from Godeps
        build(['name':'github.com/cloudfoundry/jibber_jabber', 'version':'bcc4c8345a21301bf47c032ff42dd1aae2fe3027', 'transitive':false])
        build(['name':'github.com/fatih/color', 'version':'87d4004f2ab62d0d255e0a38f1680aa534549fe3', 'transitive':false])
        build(['name':'github.com/google/go-querystring/query', 'version':'9235644dd9e52eeae6fa48efd539fdc351a0af53', 'transitive':false])
        build(['name':'github.com/hokaccha/go-prettyjson', 'version':'f75235bd99dad4e98ff360db8372d5c0ef1d054a', 'transitive':false])
        build(['name':'github.com/inconshreveable/mousetrap', 'version':'76626ae9c91c4f2a10f34cad8ce83ea42c93bb75', 'transitive':false])
        build(['name':'github.com/mattn/go-colorable', 'version':'d228849504861217f796da67fae4f6e347643f15', 'transitive':false])
        build(['name':'github.com/mattn/go-isatty', 'version':'66b8e73f3f5cda9f96b69efd03dd3d7fc4a5cdb8', 'transitive':false])
        build(['name':'github.com/mitchellh/go-homedir', 'version':'1111e456ffea841564ac0fa5f69c26ef44dafec9', 'transitive':false])
        build(['name':'github.com/nicksnyder/go-i18n/i18n/...', 'version':'37e5c2de3e03e4b82693e3fcb4a6aa2cc4eb07e3', 'transitive':false])
        build(['name':'github.com/spf13/cobra', 'version':'1238ba19d24b0b9ceee2094e1cb31947d45c3e86', 'transitive':false])
        build(['name':'github.com/spf13/pflag', 'version':'367864438f1b1a3c7db4da06a2f55b144e6784e0', 'transitive':false])
        build(['name':'golang.org/x/sys/unix', 'version':'7f918dd405547ecb864d14a8ecbbfe205b5f930f', 'transitive':false])
        build(['name':'gopkg.in/yaml.v2', 'version':'cd8b52f8269e0feb286dfeef29f8fe4d5b397e0b', 'transitive':false])
        build(['name':'github.com/ghodss/yaml', 'version':'0ca9ea5df5451ffdf184b4428c902747c2c11cd7', 'transitive':false])
        build(['name':'github.com/apache/incubator-openwhisk-client-go/whisk', 'version':'a67e8509a92beb6c68f0c9da43562af1f5d2b13c', 'transitive':false])
        // END - Imported from Godeps
        test name:'github.com/golang/lint/golint'
        test name:'github.com/stretchr/testify'
        test name:'github.com/spf13/viper'
        test name:'github.com/cpuguy83/go-md2man/md2man'
    }
}

/*
    The OpenWhiskPlatform class is a utility class to make the rest of what
    happens with platforms a bit more understandable.  A "Platform" is a tuple
    of an operating system and a processor.  Currently, the OpenWhisk CLI
    supports three OS's:  Linux, Mac/Darwin, and Windows.  It supports x86
    (32-bit or 64-bit) on all OS's.  On Linux, it also support System Z (s390x),
    PowerPC (ppc64le), and ARM (32-bit and 64-bit) architectures.

    Different contexts use different codings to refer to these architectures --
    the class attempts to provide and interpret all needed codings.  Internal
    storage is in "GO" format:

        OS: linux, darwin, windows
        Arch: 386, amd64, s390x, ppc64le, arm

    TODO - It may be appropriate to refactor into a general purpose Platform
           class for all builds, then to extend with
 */
class OpenWhiskPlatform {
    /*
        TODO - Consider the pros and cons of enums to implement this.
    */
    String goOs
    String goArch

    /*
        The 'zipFileName' property is the root file name to use for archives.
     */
    static String zipFileName

    /*
        Create a platform for the local platform
     */
    OpenWhiskPlatform() {
        this(System.properties['os.name'], System.properties['os.arch'])
    }

    OpenWhiskPlatform(String platformSpec) {
        this(*platformSpec.split('-'))
    }

    OpenWhiskPlatform(String inOs, String inArch) {
        goOs=inOs.toLowerCase()
                 .replaceAll(~/^mac.*$/,'darwin')
                 .replaceAll(~/^.*n[ui]x.*$/,'linux')
        goArch=inArch.toLowerCase()
                     .replaceAll('x86_64','amd64')
                     .replaceAll('i386','386')
                     .replaceAll('x86_32','386')
    }

    /**
     * Return the Openwhisk OS for this Platform
     */
    String getOwOs() {
        ((goOs == 'darwin') ? 'mac' : goOs)
    }

    String getGoPlatform() {
        "${goOs}-${goArch}"
    }

    /*
        Everything below here is specific to the CLI build and could be
        factored out into a subclass.
     */
    String getArchiveDirName() {
        "${this.owOs}/${goArch}"
    }

    String getArchiveFileName() {
        String suffix
        switch (goArch) {
            case "386": suffix = '-32bit'; break;
            case "amd64": suffix = ''; break;
            default: suffix = "-${goArch}"; break;
        }
        String archivetype = (goOs == 'linux') ? 'tgz' : 'zip'
        "${zipFileName}-${this.owOs}${suffix}.${archivetype}"
    }
}
OpenWhiskPlatform.zipFileName = rootProject.findProperty('zipFileName') ?: 'OpenWhisk_CLI'

/*
    'platforms' property will be null for a local compile, or a list (comma or
    space-separated) of hyphenated Goos-Goarch pairs.  Some transformation is
    done when parsing to handle misconceptions.

    TODO:  More syntax/validity checking and feedback, perhaps as part of a
    Platform object as proposed above...
*/
rootProject.ext.localPlatform = new OpenWhiskPlatform()
if (rootProject.hasProperty('buildPlatforms')) {
    rootProject.ext.platforms = buildPlatforms.tokenize(' ,')
        .collect() { new OpenWhiskPlatform(it) }
} else {
    if (rootProject.findProperty('crossCompile')) {
        rootProject.ext.platforms = [
            'linux-386', 'linux-amd64',
            'linux-s390x', 'linux-ppc64le', 'linux-arm', 'linux-arm64',
            'darwin-386', 'darwin-amd64',
            'windows-386', 'windows-amd64'
        ].collect { new OpenWhiskPlatform(it) }
    } else {
        rootProject.ext.platforms = [ rootProject.localPlatform ]
    }
}

/*
    Checks -- add golint and scancode to the checks run prior to build.
 */
task goLint(type: com.github.blindpirate.gogradle.Go) {
    run('golint ' + golang.packagePath )
}

goCheck.dependsOn(goLint)

/*
    Build
 */
goBuild {
    targetPlatform = rootProject.platforms*.goPlatform
    def now = new Date().format("yyyy-MM-dd'T'HH:mm:ss.SSSZ")

    go(['build',
      '-ldflags', "-X main.CLI_BUILD_TIME=$now" as String,
      '-o', './build/${GOOS}-${GOARCH}/wsk${GOEXE}',
      golang.packagePath ] as List<String>)
}

task buildBinaries(type: Copy, dependsOn: goBuild) {
    destinationDir = file('./bin')
    for (p in platforms) {
        from("./build/${p.goOs}-${p.goArch}") {
            into("${p.owOs}/${p.goArch}")
        }
    }
    rootProject.localPlatform.with() { l ->
        from("./build/${l.goOs}-${l.goArch}")
    }
}

/*
    Set up the goTest task to print useful information to Stdout:
 */
goTest.generateTestReport = { testClassResults ->
    testClassResults*.results.flatten()*.failures.flatten().each() { failure ->
        logger.quiet( '-' * 40 )
        logger.quiet(failure.message)
        logger.quiet( '-' * 40 )
    }
}


/*
    Individual Archives

    For each platform, create an individual archive in a platform appropriate
    format (tarball for Linux, zipfile for Mac & Windows).
 */
task individualArchives(
    dependsOn: rootProject.platforms.collect() { p ->
        task("release${p.goOs.capitalize()}${p.goArch.capitalize()}",
            type: (p.goOs == 'linux') ? Tar : Zip, dependsOn: goBuild) {
                if (p.goOs == 'linux') { compression = Compression.GZIP }
                destinationDir = file('./release')
                baseName = "${p.zipFileName}-latest-${p.owOs}-${p.goArch}"
                from "./build/${p.goOs}-${p.goArch}/"
            }
    })

/*
    Nginx tarball - create a 'content.json' file representing all that was
    compiled and its appropriate directory in the Tarball that will be created
    for deployment to local Nginx instances.

    TODO: Default architecture should be configurable as a property
 */
def content = [:]
for (p in platforms) {
    def pathObject = [ "path" : "${p.archiveDirName}/${p.archiveFileName}" ]
    content.get(p.owOs,[:])[p.goArch] = pathObject
    if (p.goArch == 'amd64') { content.get(p.owOs,[:])['default'] = pathObject }
}

task contentJson() {
    doLast {
        mkdir('./release')
        file('./release/content.json').text = groovy.json.JsonOutput.toJson(["cli":content])
    }
}

task nginxTarball(type: Tar, dependsOn: [individualArchives, contentJson]) {
    // TODO -- Add a warning if there are NO platforms defined for the build;
    //         because the archive will be meaningless.
    compression = Compression.GZIP
    destinationDir = file('./release')
    baseName = "${OpenWhiskPlatform.zipFileName}-latest-all"
    from('./release/content.json') { into('.') }
    rootProject.platforms.each() { p ->
        from('./release/') {
            include("${p.zipFileName}-latest-${p.owOs}-${p.goArch}.*")
            into p.archiveDirName
            rename { p.archiveFileName }
        }
    }
}

/*
  Note:  Okay, because nginxTarball depends on individualArchives, this
         isn't strictly all necessary, but documents the intent:  we release
         both the tarball (with content.json) and the standalone archives.
*/
task release(dependsOn: [nginxTarball, individualArchives] )

task clean(type: Delete, dependsOn: goClean) {
    delete './bin', './build', './release'
}
